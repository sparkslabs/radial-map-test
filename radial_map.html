<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Radial Map POC</title>

<style>
  body {
    margin: 0;
    font-family: system-ui, sans-serif;
    background: #1e1e24;
    color: #ddd;
    display: flex;
    flex-direction: column;
    align-items: centre;
  }

  header {
    padding: 10px 16px;
    background: #2b2b33;
    width: 100%;
    box-sizing: border-box;
  }

  #container {
    width: min(1400px, 95vw);
    aspect-ratio: 16/9;
    margin: 20px auto;
    background: #ffffff;
    border: 1px solid #444;
  }

  svg {
    width: 100%;
    height: 100%;
  }

  .cell {
    stroke: #ffffff;
    stroke-width: 1.5;
  }

  .cell:hover {
    filter: brightness(1.15);
  }

  .dot {
    fill: #ffcc66;
    stroke: #222;
    stroke-width: 1;
  }

  .dot-label {
    fill: #000;
    font-size: 11px;
    text-anchor: left;
    pointer-events: none;
  }

  .ring-label {
    fill: #000;
    font-size: 14px;
    font-weight: 600;
  }

  .segment-label {
    fill: #000;
    font-size: 13px;
  }

</style>
</head>

<body>

<header>
  <strong>Radial Map â€” version 0</strong>
</header>

<div id="container"></div>

<script type="module">
/* =======================
   Configuration
======================= */

const ring_labels = ["inner","middle","outer"];
const segment_labels = ["richard","of","york","gave","battle","in","vain"];

const CONFIG = {
  segments: segment_labels.length,  // 7,
  rings: ring_labels.length, // 3,
  radius: 350
};

const ITEMS = [
  { id:"a1", label:"Apple" },
  { id:"c3", label:"Banana" },
  { id:"d2", label:"Cat" },
  { id:"f1", label:"Dog" },
  { id:"b2", label:"Elephant" },
  { id:"e3", label:"Fox" },
  { id:"a3", label:"Grape" },
  { id:"c1", label:"Horse" }
];

/* =======================
   SVG helpers
======================= */

const NS = "http://www.w3.org/2000/svg";

function el(tag, attrs={}, children=[]) {
  const n = document.createElementNS(NS, tag);
  for (const [k,v] of Object.entries(attrs)) n.setAttribute(k, v);
  for (const c of children) n.append(c);
  return n;
}

function polar(cx, cy, r, a) {
  return { x: cx + r*Math.cos(a), y: cy + r*Math.sin(a) };
}

function sectorPath(cx, cy, r0, r1, a0, a1) {
  const p0 = polar(cx,cy,r1,a0);
  const p1 = polar(cx,cy,r1,a1);
  const p2 = polar(cx,cy,r0,a1);
  const p3 = polar(cx,cy,r0,a0);
  const large = (a1-a0) > Math.PI ? 1 : 0;

  return `
    M ${p0.x} ${p0.y}
    A ${r1} ${r1} 0 ${large} 1 ${p1.x} ${p1.y}
    L ${p2.x} ${p2.y}
    A ${r0} ${r0} 0 ${large} 0 ${p3.x} ${p3.y}
    Z
  `;
}

function hsvToCssHsl(hDeg, sPct, vPct) {

  let h = hDeg / 360;
  let s = sPct / 100;
  let v = vPct / 100;

  let l = (2 - s) * v / 2;

  if (l !== 0) {
    if (l === 1) {
      s = 0;
    } else if (l < 0.5) {
      s = s * v / (l * 2);
    } else {
      s = s * v / (2 - l * 2);
    }
  }

  // ---- clamp to SVG-safe range ----
  s = Math.max(0, Math.min(1, s));
  l = Math.max(0, Math.min(1, l));

  return `hsl(${hDeg}, ${s*100}%, ${l*100}%)`;
}

function ringS(ringIndex, rings) {
  if (rings <= 1) return max_S;
  return ((max_S - min_S) / (rings - 1)) * ((rings - 1) - ringIndex) + min_S;
}

function ringMidRadius(r, rings, maxR) {
  const r0 = maxR * (r / rings);
  const r1 = maxR * ((r+1) / rings);
  return (r0 + r1) / 2;
}

function createChunkGradient(defs, seg, ring, hueDeg, sThis, sNext, reverse=false) {

  const cThis = hsvToCssHsl(hueDeg, sThis, 100);
  const cNext = hsvToCssHsl(hueDeg, sNext, 100);

  const grad = el("radialGradient", {
    id: `chunkGrad-${seg}-${ring}`,
    gradientUnits: "userSpaceOnUse",
    cx: cx,
    cy: cy,
    r: CONFIG.radius
  });

  const c0 = reverse ? cNext : cThis;
  const c1 = reverse ? cThis : cNext;

  grad.append(
    el("stop", { offset: "0%",   "stop-color": c0 }),
    el("stop", { offset: "100%", "stop-color": c1 })
  );

  defs.append(grad);
}

/* =======================
   Random dot placement
======================= */

function randomInCell(id) {
  const g = cellGeometry[id];

  const angle = g.a0 + Math.random()*(g.a1-g.a0);
  const radius = Math.sqrt(Math.random())*(g.r1-g.r0)+g.r0;

  return polar(cx,cy,radius,angle);
}

function addItem({id,label}) {
  if (!cellGeometry[id]) return;

  const p = randomInCell(id);

  svg.append(
    el("circle",{cx:p.x,cy:p.y,r:6,class:"dot"}),
    el("text",{x:p.x+10,y:p.y+4,class:"dot-label"},[label])
  );
}

function drawRingLabels(svg, labels) {

  const rings = labels.length;

  for (let r=0; r<rings; r++) {

    const radius = ringMidRadius(r, rings, CONFIG.radius);

    // left side (mirrored order)
    const left = polar(cx, cy, radius, Math.PI);
    svg.append(
      el("text",{
        x:left.x,
        y:left.y,
        "text-anchor":"middle",
        "dominant-baseline":"middle",
        class:"ring-label"
      // },[labels[rings-1-r]])
      },[labels[r]])
    );

    // right side
    const right = polar(cx, cy, radius, 0);
    svg.append(
      el("text",{
        x:right.x,
        y:right.y,
        "text-anchor":"middle",
        "dominant-baseline":"middle",
        class:"ring-label"
      },[labels[r]])
    );
  }
}

function drawSegmentLabels(svg, labels) {

  const segments = labels.length;
  const labelRadius = CONFIG.radius + 28;

  for (let s=0; s<segments; s++) {

    const angle = ((s + 0.5)/segments)*2*Math.PI - Math.PI/2;
    const p = polar(cx, cy, labelRadius, angle);

    let rotation = angle * 180/Math.PI;

    // keep upright
    if (rotation > 90 || rotation < -90)
      rotation += 180;

    svg.append(
      el("text",{
        x:p.x,
        y:p.y,
        "text-anchor":"middle",
        "dominant-baseline":"middle",
        class:"segment-label"
      },[labels[s]])
    );
  }
}

// ===================================================================================================
//
// ACTUAL CODE STARTS HERE
//
// ===================================================================================================

const min_S = 15;
const max_S = 85;
const W = 1600;
const H = 900;
const cx = W/2;
const cy = H/2;

/* =======================
   Map build
  ======================= */

const svg = el("svg", { viewBox:`0 0 ${W} ${H}` });
document.getElementById("container").append(svg);

const letters = "abcdefghijklmnopqrstuvwxyz";

const defs = el("defs");
svg.append(defs);

/* store geometry for later dot placement */
const cellGeometry = {};

for (let s=0; s<CONFIG.segments; s++) {

  const hue = (s/CONFIG.segments)*360;

  for (let r=0; r<CONFIG.rings; r++) {
      const a0 = (s/CONFIG.segments)*2*Math.PI - Math.PI/2;
      const a1 = ((s+1)/CONFIG.segments)*2*Math.PI - Math.PI/2;

      const r0 = CONFIG.radius*(r/CONFIG.rings);
      const r1 = CONFIG.radius*((r+1)/CONFIG.rings);

      const id = letters[s]+(r+1);
      const path = sectorPath(cx,cy,r0,r1,a0,a1);

      const reverseForVisibility = true; // Looks prettier

      const sThis = ringS(r, CONFIG.rings);

      const sNext = (r === CONFIG.rings - 1)
        ? 0                                  // white in HSV terms
        : ringS(r + 1, CONFIG.rings);

      createChunkGradient(defs, s, r, hue, sThis, sNext, reverseForVisibility);

      svg.append(
        el("path", {
          d: path,
          class: "cell",
          id,
          fill: `url(#chunkGrad-${s}-${r})`
        })
      );
      cellGeometry[id] = {a0,a1,r0,r1};
  }
}

drawRingLabels(svg, ring_labels);
drawSegmentLabels(svg, segment_labels);

ITEMS.forEach(addItem);

</script>
</body>
</html>

