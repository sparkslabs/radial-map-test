<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Radial Map POC</title>

<style>
  body {
    margin: 0;
    font-family: system-ui, sans-serif;
    background: #ffffff;
    color: #222;
    display: flex;
    flex-direction: column;
    align-items: centre;
  }

  #layout {
    display: grid;
    grid-template-columns: max-content auto;
    gap: 36px;
    max-width: 1400px;
    margin: 20px 24px;
    align-items: start;

    color: #000;
  }

  #info {
    color: #000;
  }

  #info h1 {
    margin-top: 0;
    font-size: 28px;
  }

  #info p {
    line-height: 1.5;
  }

  header {
    padding: 10px 16px;
    background: #2b2b33;
    width: 100%;
    box-sizing: border-box;
  }

  #container {
    max-width: 100%;
    aspect-ratio: 10/9;
    height: min(90vh, 900px);
    width: auto;
    margin: 20px auto;
    border: 1px solid #444;  /* For handy debugging... */
    background:
      radial-gradient(circle at 30% 25%, rgba(255,255,255,0.9), #ffffff 60%);
  }

  svg {
    width: 100%;
    height: 100%;
    display: block;
    filter:
         drop-shadow(0px 0px 10px rgba(0,0,0,0.18))
         drop-shadow(0px 0px 30px rgba(0,0,0,0.2));
  }

  .cell {
    stroke: #ffffff;
    stroke-width: 1.5;
  }

  .cell:hover {
    filter: brightness(1.15);
  }

  .dot {
    fill: #ffcc66;
    stroke: #222;
    stroke-width: 1;
  }

  .dot-label {
    fill: #000;
    font-size: 13px;
    text-anchor: left;
    pointer-events: none;
  }

  .ring-label {
    fill: #000;
    font-size: 16px;
    font-weight: 600;
  }

  .segment-label {
    fill: #000;
    font-size: 16px;
    font-weight: 600;
  }
  /*   Prevent rim stealing events */
  .rim { pointer-events:none; }

@media (max-width: 1000px) {
  #layout {
    grid-template-columns: 1fr;
  }

  #info {
    max-width: 70ch;
  }
}

/* expanded / zoom mode */
body.map-expanded #layout {
  grid-template-columns: 1fr;
}

body.map-expanded #info {
  display: none;
}

/* make the svg own the viewport width */
body.map-expanded #container {
  position: relative;

  width: 100vw;
  height: auto;
  max-width: none;
 
  margin-left: calc(50% - 50vw);   /* escape parent width */
}

/* remove height constraint when zooming */
body.map-expanded #container svg {
  height: auto;
  width: 100%;
}
.hint-label {
  font-size: 18px;
  font-weight: 600;
  fill: #444;
  opacity: 0.7;
  pointer-events: none;
  user-select: none;
  font-style: italic;
}
svg:hover .hint-label {
  opacity: 1;
}


#overlay {
  position: fixed;
  inset: 0;
  z-index: 1000;
}

#overlay-backdrop {
  position: absolute;
  inset: 0;
  background: rgba(0,0,0,0.35);
}

#overlay-panel {
  position: absolute;
  left: 50%;
  top: 50%;
  transform: translate(-50%,-50%);
  background: white;
  padding: 18px;
  border-radius: 10px;
  box-shadow: 0 20px 60px rgba(0,0,0,0.35);
}

#overlay-svg {
  width: 1000px;
  height: 500px;
}

.ring-heading {
  font-weight: 600;
  font-size: 14px;
  fill: #333;
  pointer-events: none;
}


.map-link { cursor: pointer; }

.map-link text {
  transition: fill 120ms ease, text-decoration 120ms ease;
}

.map-link:hover text {
  fill: #0a58ca;
  text-decoration: underline;
}

.map-link circle {
  transition: r 120ms ease, fill 120ms ease;
}

.map-link:hover circle {
  r: 7;
  fill: #0a58ca;
}


</style>
</head>

<body>

<header>
  <strong>Radial Map â€” version 0</strong>
</header>

<div id="layout">
  <div id="container"></div>

  <aside id="info">
    <h1>Radial Map</h1>
    <p>
      Lorem ipsum dolor sit amet, consectetur adipiscing elit. 
      Praesent vitae eros eget tellus tristique bibendum. 
      Donec rutrum sed sem quis venenatis. Proin viverra risus a eros volutpat tempor.
    </p>
  </aside>
</div>

<script type="module">

//
// This interface provides the follow 3 hooks to add behaviour to the code:
//
// hooks.onSegment(segmentLabel)
// hooks.onChunk(segmentLabel, ringLabel)
// hooks.onItem(segmentLabel, ringLabel, itemObject)
// 

/* =======================
   Configuration
======================= */


const ring_labels = ["Analysis","Prototype","Infrastructure"];
const segment_labels = [ "Compatibility", "FAIRness",
                         "Flexibility", "Functional Suitability",
                         "Interaction Capability", "Maintainability",
                         "Performance Efficiency", "Reliability",
                         "Safety", "Security",
                         "Sustainability" ]

const ITEMS = [
  { id:"a1", label:"resqui", href:"https://everse.software/TechRadar/compatibility/resqui_Compatibility/"},
  { id:"a3", label:"Docker", href:"http://everse.software/TechRadar/compatibility/docker_Compatibility/"},
  { id:"a3", label:"Apptainer", href:"https://everse.software/TechRadar/compatibility/apptainer_Compatibility/" },
  { id:"a3", label:"SingularityCE", href:"https://everse.software/TechRadar/compatibility/singularityce_Compatibility/"},
  { id:"a3", label:"CMAKE", href:"https://everse.software/TechRadar/compatibility/cmake_Compatibility/"},

  { id:"b1", label:"resqui", href:"https://everse.software/TechRadar/fairness/resqui_FAIRness/"},
  { id:"b1", label:"SQAaas", href:"https://everse.software/TechRadar/fairness/sqaaas/"},
  { id:"b1", label:"eOSSR", href:"https://everse.software/TechRadar/fairness/eossr/"},
  { id:"b1", label:"Fair-Aware tool", href:"https://everse.software/TechRadar/fairness/fair-aware_tool/"},
  { id:"b1", label:"Five Recommendations for FAIR Software", href:"https://everse.software/TechRadar/fairness/five_recommendations_for_fair_software/"},
  { id:"b2", label:"REUSE", href:"https://everse.software/TechRadar/fairness/reuse/"},
  { id:"b2", label:"Fair Python CookieCutter", href:"https://everse.software/TechRadar/fairness/fair_python_cookiecutter/"},
  { id:"b3", label:"zenodo", href:"https://everse.software/TechRadar/fairness/zenodo_FAIRness/"},
  { id:"b3", label:"Hermes Workflows", href:"https://everse.software/TechRadar/fairness/hermes_workflows_FAIRness/"},
  { id:"b3", label:"howfairis", href:"https://everse.software/TechRadar/fairness/howfairis/"},
  { id:"b3", label:"F-UJI", href:"https://everse.software/TechRadar/fairness/f-uji/"},
  { id:"b3", label:"DVC", href:"https://everse.software/TechRadar/fairness/dvc_FAIRness/"},
  { id:"b3", label:"SOMEF", href:"https://everse.software/TechRadar/fairness/somef/"},
  { id:"b3", label:"cffinit", href:"https://everse.software/TechRadar/fairness/cffinit/"},
  { id:"b3", label:"CC-License Chooser", href:"https://everse.software/TechRadar/fairness/creative_commons_license_chooser/"},
  { id:"b3", label:"Somesy", href:"https://everse.software/TechRadar/fairness/somesy/"},
  { id:"b3", label:"CodeMeta Generator", href:"https://everse.software/TechRadar/fairness/codemeta_generator/"},
  { id:"c1", label:"resqui", href:"https://everse.software/TechRadar/flexibility/resqui_Flexibility/"},
  { id:"c2", label:"pypi", href:"https://everse.software/TechRadar/flexibility/pypi_Flexibility/"},
  { id:"c3", label:"SingularityCE", href:"https://everse.software/TechRadar/flexibility/singularityce_Flexibility/"},
  { id:"c3", label:"Nix", href:"https://everse.software/TechRadar/flexibility/nix_Flexibility/"},
  { id:"c3", label:"Docker", href:"https://everse.software/TechRadar/flexibility/docker_Flexibility/"},
  { id:"c3", label:"Apptainer", href:"https://everse.software/TechRadar/flexibility/apptainer_Flexibility/"},

  { id:"d1", label:"resqui", href:"https://everse.software/TechRadar/functional_suitability/resqui_Functional_Suitability/"},
  { id:"e1", label:"resqui", href:"https://everse.software/TechRadar/interaction_capability/resqui_Interaction_Capability/"},
  { id:"e2", label:"mkDocs", href:"https://everse.software/TechRadar/interaction_capability/mkdocs_Interaction_Capability/"},
  { id:"e3", label:"tox", href:"https://everse.software/TechRadar/interaction_capability/tox_Interaction_Capability/"},
  { id:"e3", label:"Jupyter", href:"https://everse.software/TechRadar/interaction_capability/jupyter_Interaction_Capability/"},
  { id:"f1", label:"resqui", href:"https://everse.software/TechRadar/maintainability/resqui_Maintainability/"},
  { id:"f1", label:"Checkstyle", href:"https://everse.software/TechRadar/maintainability/checkstyle/"},
  { id:"f1", label:"Hadolint", href:"https://everse.software/TechRadar/maintainability/hadolint_Maintainability/"},
  { id:"f1", label:"valgrind", href:"https://everse.software/TechRadar/maintainability/valgrind_Maintainability/"},
  { id:"f1", label:"pre-commit", href:"https://everse.software/TechRadar/maintainability/pre-commit_Maintainability/"},
  { id:"f1", label:"gcov", href:"https://everse.software/TechRadar/maintainability/gcov_Maintainability/"},
  { id:"f1", label:"ruff", href:"https://everse.software/TechRadar/maintainability/ruff/"},
  { id:"f1", label:"Qlty", href:"https://everse.software/TechRadar/maintainability/qlty/"},
  { id:"f1", label:"doxygen", href:"https://everse.software/TechRadar/maintainability/doxygen/"},
  { id:"f1", label:"pytest", href:"https://everse.software/TechRadar/maintainability/pytest_Maintainability/"},
  { id:"f1", label:"flake8", href:"https://everse.software/TechRadar/maintainability/flake8/"},
  { id:"f1", label:"pylint", href:"https://everse.software/TechRadar/maintainability/pylint/"},
  { id:"f2", label:"poetry", href:"https://everse.software/TechRadar/maintainability/poetry_Maintainability/"},
  { id:"f2", label:"black", href:"https://everse.software/TechRadar/maintainability/black/"},
  { id:"f2", label:"pypi", href:"https://everse.software/TechRadar/maintainability/pypi_Maintainability/"},
  { id:"f2", label:"CppUnit", href:"https://everse.software/TechRadar/maintainability/cppunit_Maintainability/"},
  { id:"f2", label:"mkDocs", href:"https://everse.software/TechRadar/maintainability/mkdocs_Maintainability/"},
  { id:"f3", label:"sphinx", href:"https://everse.software/TechRadar/maintainability/sphinx/"},
  { id:"f3", label:"cmake", href:"https://everse.software/TechRadar/maintainability/cmake_Maintainability/"},
  { id:"f3", label:"Hermes Workflows", href:"https://everse.software/TechRadar/maintainability/hermes_workflows_Maintainability/"},
  { id:"f3", label:"Kubernetes", href:"https://everse.software/TechRadar/maintainability/kubernetes_Maintainability/"},
  { id:"f3", label:"Jupyter", href:"https://everse.software/TechRadar/maintainability/jupyter_Maintainability/"},
  { id:"f3", label:"Jenkins", href:"https://everse.software/TechRadar/maintainability/jenkins_Maintainability/"},
  { id:"f3", label:"GNU Guix", href:"https://everse.software/TechRadar/maintainability/gnu_guix_Maintainability/"},
  { id:"f3", label:"tox", href:"https://everse.software/TechRadar/maintainability/tox_Maintainability/"},
  { id:"f3", label:"Travis CI", href:"https://everse.software/TechRadar/maintainability/travis_ci_Maintainability/"},
  { id:"f3", label:"javadoc", href:"https://everse.software/TechRadar/maintainability/javadoc_Maintainability/"},
  { id:"f3", label:"Junit", href:"https://everse.software/TechRadar/maintainability/junit_Maintainability/"},
  { id:"f3", label:"SonarQube", href:"https://everse.software/TechRadar/maintainability/sonarqube_Maintainability/"},
  { id:"f3", label:"Git", href:"https://everse.software/TechRadar/maintainability/git/"},
  { id:"f3", label:"SCANOSS", href:"https://everse.software/TechRadar/maintainability/scanoss_Maintainability/"},
  { id:"f3", label:"Dependabot", href:"https://everse.software/TechRadar/maintainability/dependabot_Maintainability/"},
  { id:"g1", label:"resqui", href:"https://everse.software/TechRadar/performance_efficiency/resqui_Performance_Efficiency/"},
  { id:"g1", label:"valgrind", href:"https://everse.software/TechRadar/performance_efficiency/valgrind_Performance_Efficiency/"},
  { id:"g1", label:"score-p", href:"https://everse.software/TechRadar/performance_efficiency/score-p/"},

  { id:"h1", label:"resqui", href:"https://everse.software/TechRadar/reliability/resqui_Reliability/"},
  { id:"h1", label:"valgrind", href:"https://everse.software/TechRadar/reliability/valgrind_Reliability/"},
  { id:"h1", label:"pytest", href:"https://everse.software/TechRadar/reliability/pytest_Reliability/"},
  { id:"h2", label:"CppUnit", href:"https://everse.software/TechRadar/reliability/cppunit_Reliability/"},
  { id:"h2", label:"Github Actions", href:"https://everse.software/TechRadar/reliability/github_actions_Reliability/"},
  { id:"h3", label:"JUnit", href:"https://everse.software/TechRadar/reliability/junit_Reliability/"},
  { id:"h3", label:"tox", href:"https://everse.software/TechRadar/reliability/tox_Reliability/"},
  { id:"h3", label:"Docker", href:"https://everse.software/TechRadar/reliability/docker_Reliability/"},
  { id:"h3", label:"GNU Guix", href:"https://everse.software/TechRadar/reliability/gnu_guix_Reliability/"},
  { id:"h3", label:"Gitlab CICD", href:"https://everse.software/TechRadar/reliability/gitlab_cicd_Reliability/"},
  { id:"h3", label:"Jenkins", href:"https://everse.software/TechRadar/reliability/jenkins_Reliability/"},
  { id:"h3", label:"SonarQube", href:"https://everse.software/TechRadar/reliability/sonarqube_Reliability/"},
  { id:"h3", label:"Kubernetes", href:"https://everse.software/TechRadar/reliability/kubernetes_Reliability/"},
  { id:"h3", label:"Apptainer", href:"https://everse.software/TechRadar/reliability/apptainer_Reliability/"},
  { id:"h3", label:"Travis CI", href:"https://everse.software/TechRadar/reliability/travis_ci_Reliability/"},
  { id:"h3", label:"Nix", href:"https://everse.software/TechRadar/reliability/nix_Reliability/"},
  { id:"i1", label:"resqui", href:"https://everse.software/TechRadar/safety/resqui_Safety/"},

  { id:"j1", label:"resqui", href:"https://everse.software/TechRadar/security/resqui_Security/"},
  { id:"j1", label:"bandit", href:"https://everse.software/TechRadar/security/bandit/"},
  { id:"j1", label:"Gitleaks", href:"https://everse.software/TechRadar/security/gitleaks_Security/"},
  { id:"j1", label:"Hadolint", href:"https://everse.software/TechRadar/security/hadolint_Security/"},
  { id:"j1", label:"bearer", href:"https://everse.software/TechRadar/security/bearer/"},
  { id:"j3", label:"SonarQube", href:"https://everse.software/TechRadar/security/sonarqube_Security/"},
  { id:"j3", label:"SCANOSS", href:"https://everse.software/TechRadar/security/scanoss_Security/"},
  { id:"j3", label:"Nix", href:"https://everse.software/TechRadar/security/nix_Security/"},
  { id:"j3", label:"Dependabot", href:"https://everse.software/TechRadar/security/dependabot_Security/"},

  { id:"k1", label:"resqui", href:"https://everse.software/TechRadar/sustainability/resqui_Sustainability/"},
  { id:"k1", label:"Github Copilot", href:"https://everse.software/TechRadar/sustainability/github_copilot/"},
  { id:"k1", label:"Choose a License", href:"https://everse.software/TechRadar/sustainability/choose_a_license/"},
  { id:"k1", label:"pre-commit", href:"https://everse.software/TechRadar/sustainability/pre-commit_Sustainability/"},
  { id:"k1", label:"Gitleaks", href:"https://everse.software/TechRadar/sustainability/gitleaks_Sustainability/"},
  { id:"k1", label:"gcov", href:"https://everse.software/TechRadar/sustainability/gcov_Sustainability/"},
  { id:"k1", label:"valgrind", href:"https://everse.software/TechRadar/sustainability/valgrind_Sustainability/"},
  { id:"k2", label:"Zenodo github Integration", href:"https://everse.software/TechRadar/sustainability/zenodo_github_integration/"},
  { id:"k2", label:"Github Actions", href:"https://everse.software/TechRadar/sustainability/github_actions_Sustainability/"},
  { id:"k2", label:"poetry", href:"https://everse.software/TechRadar/sustainability/poetry_Sustainability/"},

  { id:"k3", label:"GNU Guix", href:"https://everse.software/TechRadar/sustainability/gnu_guix_Sustainability/"},
  { id:"k3", label:"Docker", href:"https://everse.software/TechRadar/sustainability/docker_Sustainability/"},
  { id:"k3", label:"zenodo", href:"https://everse.software/TechRadar/sustainability/zenodo_Sustainability/"},
  { id:"k3", label:"javadoc", href:"https://everse.software/TechRadar/sustainability/javadoc_Sustainability/"},
  { id:"k3", label:"Gitlab CICD", href:"https://everse.software/TechRadar/sustainability/gitlab_cicd_Sustainability/"},
  { id:"k3", label:"DVC", href:"https://everse.software/TechRadar/sustainability/dvc_Sustainability/"},
  { id:"k3", label:"Apptainer", href:"https://everse.software/TechRadar/sustainability/apptainer_Sustainability/"},
  { id:"k3", label:"tox", href:"https://everse.software/TechRadar/sustainability/tox_Sustainability/"},
  { id:"k3", label:"Software Heritage", href:"https://everse.software/TechRadar/sustainability/software_heritage/"},
  { id:"k3", label:"Kubertnetes", href:"https://everse.software/TechRadar/sustainability/kubernetes_Sustainability/"},
  { id:"k3", label:"Hermes Workflows", href:"https://everse.software/TechRadar/sustainability/hermes_workflows_Sustainability/"}
];

const W = 1000;
const H = 900;

const CONFIG = {
  segments: segment_labels.length,  // 7,
  rings: ring_labels.length, // 3,
  radius: 400 // Default initial value, gets overwritten below
};

const padding = 40;
const radius = Math.min(W,H)/2 - padding;
CONFIG.radius = radius;

export const hooks = {
  onSegment: (segment)=>{},
  onChunk:   (segment,ring)=>{},
  onItem:    (segment,ring,item)=>{}
};


/* =======================
   SVG helpers
======================= */

const NS = "http://www.w3.org/2000/svg";

function el(tag, attrs={}, children=[]) {
  const n = document.createElementNS(NS, tag);
  for (const [k,v] of Object.entries(attrs)) n.setAttribute(k, v);
  for (const c of children) n.append(c);
  return n;
}

function polar(cx, cy, r, a) {
  return { x: cx + r*Math.cos(a), y: cy + r*Math.sin(a) };
}

function sectorPath(cx, cy, r0, r1, a0, a1) {
  const p0 = polar(cx,cy,r1,a0);
  const p1 = polar(cx,cy,r1,a1);
  const p2 = polar(cx,cy,r0,a1);
  const p3 = polar(cx,cy,r0,a0);
  const large = (a1-a0) > Math.PI ? 1 : 0;

  return `
    M ${p0.x} ${p0.y}
    A ${r1} ${r1} 0 ${large} 1 ${p1.x} ${p1.y}
    L ${p2.x} ${p2.y}
    A ${r0} ${r0} 0 ${large} 0 ${p3.x} ${p3.y}
    Z
  `;
}

function hsvToCssHsl(hDeg, sPct, vPct) {

  let h = hDeg / 360;
  let s = sPct / 100;
  let v = vPct / 100;

  let l = (2 - s) * v / 2;

  if (l !== 0) {
    if (l === 1) {
      s = 0;
    } else if (l < 0.5) {
      s = s * v / (l * 2);
    } else {
      s = s * v / (2 - l * 2);
    }
  }

  // ---- clamp to SVG-safe range ----
  s = Math.max(0, Math.min(1, s));
  l = Math.max(0, Math.min(1, l));

  return `hsl(${hDeg}, ${s*100}%, ${l*100}%)`;
}

function ringS(ringIndex, rings) {
  if (rings <= 1) return max_S;
  return ((max_S - min_S) / (rings - 1)) * ((rings - 1) - ringIndex) + min_S;
}

function ringMidRadius(r, rings, maxR) {
  const r0 = maxR * (r / rings);
  const r1 = maxR * ((r+1) / rings);
  return (r0 + r1) / 2;
}

function createChunkGradient(defs, seg, ring, hueDeg, sThis, sNext, r0, r1, reverse=false) {

  const cThis = hsvToCssHsl(hueDeg, sThis, 100);
  const cNext = hsvToCssHsl(hueDeg, sNext, 100);

  const grad = el("radialGradient", {
    id: `chunkGrad-${seg}-${ring}`,
    gradientUnits: "userSpaceOnUse",

    cx: cx,
    cy: cy,
    r: r1,

    fx: cx,
    fy: cy,
    fr: r0
  });


  const c0 = reverse ? cNext : cThis;
  const c1 = reverse ? cThis : cNext;

  grad.append(
    el("stop", { offset: "0%",   "stop-color": c0 }),
    el("stop", { offset: "100%", "stop-color": c1 })
  );

  defs.append(grad);

}

/* =======================
   Random dot placement
======================= */

function randomInCell(id) {
  const g = cellGeometry[id];

  const angle = g.a0 + Math.random()*(g.a1-g.a0);
  const radius = Math.sqrt(Math.random())*(g.r1-g.r0)+g.r0;

  return polar(cx,cy,radius,angle);
}

function drawRingLabels(svg, labels) {

  const rings = labels.length;

  for (let r=0; r<rings; r++) {

    const radius = ringMidRadius(r, rings, CONFIG.radius);

    // left side (mirrored order)
    const left = polar(cx, cy, radius, Math.PI);
    svg.append(
      el("text",{
        x:left.x,
        y:left.y,
        "text-anchor":"middle",
        "dominant-baseline":"middle",
        class:"ring-label"
      // },[labels[rings-1-r]])
      },[labels[r]])
    );

    // right side
    const right = polar(cx, cy, radius, 0);
    svg.append(
      el("text",{
        x:right.x,
        y:right.y,
        "text-anchor":"middle",
        "dominant-baseline":"middle",
        class:"ring-label"
      },[labels[r]])
    );
  }
}

function drawSegmentLabels(svg, labels) {

  const segments = labels.length;
  const labelRadius = CONFIG.radius + 28;

  for (let s=0; s<segments; s++) {

    const angle = ((s + 0.5)/segments)*2*Math.PI - Math.PI/2;
    const p = polar(cx, cy, labelRadius, angle);

    const href = `#segment-${encodeURIComponent(labels[s])}`;

    svg.append(
      el("a",{class:"map-link", href},
        [el("text",{
          x:p.x,
          y:p.y,
          "text-anchor":"middle",
          "dominant-baseline":"middle",
          class:"segment-label",
          "data-segment": labels[s]
        },[labels[s]])]
      )
    );


  }
}

function outerArcPath(cx, cy, r, a0, a1) {
  const p0 = polar(cx, cy, r, a0);
  const p1 = polar(cx, cy, r, a1);
  const large = (a1-a0) > Math.PI ? 1 : 0;

  return `M ${p0.x} ${p0.y}
          A ${r} ${r} 0 ${large} 1 ${p1.x} ${p1.y}`;
}

function gridToPolar(cell, gx, gy, N) {
  const u = (gx + 0.5)/N;
  const v = (gy + 0.5)/N;

  const angle  = cell.a0 + u*(cell.a1-cell.a0);
  const radius = cell.r0 + v*(cell.r1-cell.r0);

  return polar(cx, cy, radius, angle);
}

function hashString(str) {
  // FNV-1a based hash
  let h = 2166136261;
  for (let i=0;i<str.length;i++) {
    h ^= str.charCodeAt(i);
    h = Math.imul(h,16777619);
  }
  return h>>>0;
}


function placeInCell(cellId, item) {
  if (!occupancy[cellId])
    occupancy[cellId] = new Map();

  const ringIndex = Number(cellId.slice(1)) - 1;
  const isInnerRing = (ringIndex === 0);

  let h = hashString(item.label);

  for (let attempt=0; attempt<GRID*GRID*2; attempt++) {

    const x = h % GRID;
    const y = Math.floor(h / GRID) % GRID;

    // --- NEW RULE ---
    // Avoid centre distortion: reserve first 2 radial rows in inner ring
    if (isInnerRing && y < 2) {
      h = (h*1664525 + 1013904223) >>> 0;
      continue;
    }

    const key = `${x},${y}`;

    if (!occupancy[cellId].has(key)) {
      occupancy[cellId].set(key, item);
      return gridToPolar(cellGeometry[cellId], x, y, GRID);
    }

    h = (h*1664525 + 1013904223) >>> 0;
  }

  return null; // cell full
}





function itemHref(item) {
  // placeholder canonical URL
  return `/item/${encodeURIComponent(item.label.toLowerCase().replace(/\s+/g,'-'))}.html`;
}

function addItem(item) {
  const {id,label} = item;
  if (!cellGeometry[id]) return;

  const p = placeInCell(id,item);
  if (!p) return;

  const segIndex = letters.indexOf(id[0]);
  const ringIndex = Number(id.slice(1))-1;

  const link = el("a",{
    class:"map-link",
    href: item.href ?? itemHref(item)
  });

  const group = el("g",{
    class:"item",
    "data-segment": segment_labels[segIndex],
    "data-ring": ring_labels[ringIndex]
  });

  group.__data = item;

  group.append(
    el("circle",{cx:p.x,cy:p.y,r:6,class:"dot"}),
    el("text",{x:p.x+10,y:p.y+4,class:"dot-label"},[label])
  );

  link.append(group);
  svg.append(link);
}

function gridToChunkCartesian(cellId, gx, gy, grid, width, height){

  const padding = 10;

  const usableW = width - padding*2;
  const usableH = height - padding*2;

  const cellW = usableW / grid;
  const cellH = usableH / grid;

  const flippedY = (grid - 1) - gy;

  return {
    x: padding + gx*cellW + cellW/2,
    y: padding + flippedY*cellH + cellH/2
  };
}


function renderSingleChunkInto(svgTarget, cellId, offsetX, offsetY, width, height, segmentLabel, ringLabel) {

  const segIndex = segment_labels.indexOf(segmentLabel);
  const ringIndex = ring_labels.indexOf(ringLabel);

  svgTarget.append(
    el("rect",{
      x: offsetX, y: offsetY, width, height,
      fill:`url(#chunkGrad-${segIndex}-${ringIndex})`
    })
  );

  // draw grid
  const gridGroup = el("g",{stroke:"#ddd","stroke-width":1,fill:"none"});
  svgTarget.append(gridGroup);

  const GRID = 7;
  const padding = 10;
  const usableW = width - padding*2;
  const usableH = height - padding*2;

  for(let i=0;i<=GRID;i++){
    const x = offsetX + padding + usableW*i/GRID;
    const y = offsetY + padding + usableH*i/GRID;

    gridGroup.append(
      el("line",{x1:x, y1:offsetY+padding, x2:x, y2:offsetY+height-padding}),
      el("line",{x1:offsetX+padding, y1:y, x2:offsetX+width-padding, y2:y})
    );
  }

  // draw items
  const items = occupancy[cellId];
  if(!items) return;

  items.forEach((item,key)=>{
    const [gx,gy] = key.split(",").map(Number);
    const p = gridToChunkCartesian(cellId,gx,gy,GRID,width,height);

    const link = el("a",{class:"map-link", href:item.href ?? itemHref(item)});

    link.append(
      el("circle",{cx:p.x + offsetX ,cy:p.y + offsetY ,r:5,class:"dot"}),
      el("text",{
        x:p.x+8 + offsetX ,y:p.y+4  + offsetY,
        transform:`rotate(-22 ${p.x+8 + offsetX } ${p.y+4  + offsetY})`, // Unclear
        class:"dot-label"
      },[item.label])
    );

    svgTarget.append(link);
  });
}

function renderSegmentOverlay(segmentLabel){

  overlay.hidden = false;
  overlaySvg.replaceChildren();

  const headerH = 28;
  // const widthPerChunk = 260;
  const widthPerChunk = 370;
  const height = 500;
  const chunkH = 500;
  const totalW = widthPerChunk * ring_labels.length;
  const totalH = chunkH + headerH;

  // overlaySvg.setAttribute("viewBox", `0 0 ${totalW} ${height}`);
  overlaySvg.setAttribute("viewBox", `0 0 ${totalW} ${totalH}`);
  document.getElementById("overlay-title").textContent = segmentLabel;

  // defs ONCE
  overlaySvg.append(document.querySelector("svg defs").cloneNode(true));

  const segIndex = segment_labels.indexOf(segmentLabel);

  ring_labels.forEach((ringLabel, ringIndex)=>{
    const cellId = letters[segIndex] + (ringIndex+1);

    renderSingleChunkInto(
      overlaySvg,
      cellId,
      ringIndex * widthPerChunk,  // offsetX
      headerH,
      widthPerChunk,
      chunkH,
      segmentLabel,
      ringLabel
    );

    overlaySvg.append(
      el("text",{
        x: ringIndex * widthPerChunk + widthPerChunk/2,
        y: headerH - 8,
        "text-anchor": "middle",
        class: "ring-heading"
      },[ringLabel])
    );

  });
}

function renderChunkOverlay(segmentLabel, ringLabel){

  overlay.hidden = false;
  overlaySvg.replaceChildren();

  const width = 1000;
  const height = 500;

  overlaySvg.setAttribute("viewBox", `0 0 ${width} ${height}`);
  document.getElementById("overlay-title").textContent =
    `${segmentLabel} > ${ringLabel}`;

  overlaySvg.append(document.querySelector("svg defs").cloneNode(true));

  const segIndex = segment_labels.indexOf(segmentLabel);
  const ringIndex = ring_labels.indexOf(ringLabel);
  const cellId = letters[segIndex] + (ringIndex+1);

  renderSingleChunkInto(overlaySvg, cellId, 0, 0, width, height, segmentLabel, ringLabel);
}


const GRID = 7;
const occupancy = {};  // id -> Set("x,y")


// ===================================================================================================
//
// ACTUAL CODE STARTS HERE
//
// ===================================================================================================

const min_S = 15;
const max_S = 60;
const cx = W/2;
const cy = H/2;

/* =======================
   Map build
  ======================= */

const svg = el("svg", { viewBox:`0 0 ${W} ${H}` });
document.getElementById("container").append(svg);

const letters = "abcdefghijklmnopqrstuvwxyz";

const defs = el("defs");
svg.append(defs);

const board = el("g",{});
svg.append(board);

const uiLayer = el("g",{class:"ui"});
svg.append(uiLayer);

const hintText = el("text",{
  class:"hint-label",
  "text-anchor":"end",
  "dominant-baseline":"hanging"
});

uiLayer.append(hintText);

function placeHint() {
  hintText.setAttribute("x", W - 16);
  hintText.setAttribute("y", 16);
}

placeHint();

function updateHint() {
  hintText.textContent =
    document.body.classList.contains("map-expanded")
      ? "escape to exit"
      : "click outside circle to zoom";
}

updateHint();

const observer = new MutationObserver(updateHint);

observer.observe(document.body, {
  attributes: true,
  attributeFilter: ["class"]
});

requestAnimationFrame(updateHint);


/* store geometry for later dot placement */
const cellGeometry = {};

for (let s=0; s<CONFIG.segments; s++) {

  const hue = (s/CONFIG.segments)*360;

  for (let r=0; r<CONFIG.rings; r++) {
      const a0 = (s/CONFIG.segments)*2*Math.PI - Math.PI/2;
      const a1 = ((s+1)/CONFIG.segments)*2*Math.PI - Math.PI/2;

      const r0 = CONFIG.radius*(r/CONFIG.rings);
      const r1 = CONFIG.radius*((r+1)/CONFIG.rings);

      const id = letters[s]+(r+1);
      const path = sectorPath(cx,cy,r0,r1,a0,a1);

      const reverseForVisibility = true; // Looks prettier

      const sThis = ringS(r, CONFIG.rings);

      const sNext = (r === CONFIG.rings - 1)
        ? 0                                  // white in HSV terms
        : ringS(r + 1, CONFIG.rings);

      createChunkGradient(defs, s, r, hue, sThis, sNext, r0, r1, reverseForVisibility);

      const segmentLabel = segment_labels[s];
      const ringLabel = ring_labels[r];

      const chunkHref =
        `#chunk-${encodeURIComponent(segmentLabel)}-${encodeURIComponent(ringLabel)}`;

      const link = el("a",{class:"map-link", href:chunkHref});

      link.append(
        el("path", {
          d: path,
          class: "cell",
          id,
          fill: `url(#chunkGrad-${s}-${r})`,
          "data-segment": segmentLabel,
          "data-ring": ringLabel
        })
      );

      board.append(link);

      cellGeometry[id] = {a0,a1,r0,r1};
  }
}

const rimLayer = el("g",{class:"rim"});
board.append(rimLayer);

for (let s=0; s<CONFIG.segments; s++) {

  const hue = (s/CONFIG.segments)*360;

  const a0 = (s/CONFIG.segments)*2*Math.PI - Math.PI/2;
  const a1 = ((s+1)/CONFIG.segments)*2*Math.PI - Math.PI/2;

  rimLayer.append(
    el("path",{
      d: outerArcPath(cx, cy, CONFIG.radius, a0, a1),
      stroke: hsvToCssHsl(hue,100,100),
      "stroke-width": 2,
      fill:"none",
      "stroke-linecap":"round"
    })
  );
}

drawRingLabels(svg, ring_labels);
drawSegmentLabels(svg, segment_labels);

ITEMS.forEach(addItem);

const overlay = document.getElementById("overlay");
const overlaySvg = document.getElementById("overlay-svg");

document.getElementById("overlay-backdrop")
  .addEventListener("click", closeOverlay);

function closeOverlay(){
  overlay.hidden = true;
  overlaySvg.replaceChildren();
}



svg.addEventListener("click", (ev) => {

  // --- ITEM ---
  const item = ev.target.closest(".item");
  if (item) {
    const handled = hooks.onItem(
      item.dataset.segment,
      item.dataset.ring,
      item.__data
    );
    if (handled === true) ev.preventDefault();
    return;
  }

  // --- CHUNK ---
  const chunk = ev.target.closest(".cell");
  if (chunk) {
    const handled = hooks.onChunk(
      chunk.dataset.segment,
      chunk.dataset.ring
    );
    if (handled === true) ev.preventDefault();
    return;
  }

  // --- SEGMENT ---
  const seg = ev.target.closest(".segment-label");
  if (seg) {
    const handled = hooks.onSegment(seg.dataset.segment);
    if (handled === true) ev.preventDefault();
    return;
  }

  // --- background zoom ---
  const rect = svg.getBoundingClientRect();
  const x = (ev.clientX - rect.left) * (W / rect.width);
  const y = (ev.clientY - rect.top)  * (H / rect.height);

  const dx = x - cx;
  const dy = y - cy;
  const dist = Math.sqrt(dx*dx + dy*dy);

  if (dist > CONFIG.radius)
    document.body.classList.toggle("map-expanded");
});


window.addEventListener("keydown", e=>{
  if(e.key==="Escape") {
    document.body.classList.remove("map-expanded");
    updateHint();
    closeOverlay();
  }
});

hooks.onItem = (s,r,item)=>{
  console.log("ITEM",s,r,item);
  return false;   // allow navigation
};

hooks.onChunk = (segment,ring)=>{
  console.log("CHUNK",segment,ring);
  renderChunkOverlay(segment,ring);
  return true;
};

hooks.onSegment = (segment)=>{
  renderSegmentOverlay(segment);
  return true;
};

</script>

<div id="overlay" hidden>
  <div id="overlay-backdrop"></div>
  <div id="overlay-panel">
    <h2 id="overlay-title"></h2>
    <svg id="overlay-svg"></svg>
  </div>
</div>
</body>
</html>

